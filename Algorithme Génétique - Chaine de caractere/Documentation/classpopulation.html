<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>Algorithme Genetique: Référence de la classe population</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Algorithme Genetique
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Généré par Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Recherche');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Page&#160;principale</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Fichiers</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Recherche" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Liste&#160;des&#160;classes</span></a></li>
      <li><a href="classes.html"><span>Index&#160;des&#160;classes</span></a></li>
      <li><a href="functions.html"><span>Membres&#160;de&#160;classe</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Fonctions membres publiques</a> &#124;
<a href="classpopulation-members.html">Liste de tous les membres</a>  </div>
  <div class="headertitle">
<div class="title">Référence de la classe population</div>  </div>
</div><!--header-->
<div class="contents">

<p>Classe population.  
 <a href="classpopulation.html#details">Plus de détails...</a></p>

<p><code>#include &lt;<a class="el" href="population_8h_source.html">population.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Fonctions membres publiques</h2></td></tr>
<tr class="memitem:a9866a5e2211df558b8e63e30177a4ae1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpopulation.html#a9866a5e2211df558b8e63e30177a4ae1">population</a> ()</td></tr>
<tr class="separator:a9866a5e2211df558b8e63e30177a4ae1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ba6cfda62b8534be70ae3945a906d05"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpopulation.html#a6ba6cfda62b8534be70ae3945a906d05">~population</a> ()</td></tr>
<tr class="separator:a6ba6cfda62b8534be70ae3945a906d05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1d61dd5910f85fd9d327de3910c33e0"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="classgenome.html">genome</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpopulation.html#ab1d61dd5910f85fd9d327de3910c33e0">getpop</a> () const </td></tr>
<tr class="separator:ab1d61dd5910f85fd9d327de3910c33e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a751d56be6b96d71f3d9457c137a10db1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpopulation.html#a751d56be6b96d71f3d9457c137a10db1">setpop</a> (vector&lt; <a class="el" href="classgenome.html">genome</a> &gt;)</td></tr>
<tr class="separator:a751d56be6b96d71f3d9457c137a10db1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dd43bd359b929c93819e57ba5d86c30"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgenome.html">genome</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpopulation.html#a3dd43bd359b929c93819e57ba5d86c30">getbestgenome</a> () const </td></tr>
<tr class="memdesc:a3dd43bd359b929c93819e57ba5d86c30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Méthode qui renvoie le génome avec la meilleure fitness.  <a href="#a3dd43bd359b929c93819e57ba5d86c30">Plus de détails...</a><br /></td></tr>
<tr class="separator:a3dd43bd359b929c93819e57ba5d86c30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8df089ad3944b829708ff65e14b913ba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpopulation.html#a8df089ad3944b829708ff65e14b913ba">update_muterate</a> (double &amp;d)</td></tr>
<tr class="memdesc:a8df089ad3944b829708ff65e14b913ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fonction de mise à jour du Muterate variable si l'algorithme vient à stagner.  <a href="#a8df089ad3944b829708ff65e14b913ba">Plus de détails...</a><br /></td></tr>
<tr class="separator:a8df089ad3944b829708ff65e14b913ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a680cb232cc5534822c396a6ead82c3e3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpopulation.html#a680cb232cc5534822c396a6ead82c3e3">initialiser_population</a> ()</td></tr>
<tr class="memdesc:a680cb232cc5534822c396a6ead82c3e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Méthode de création d'une population vide.  <a href="#a680cb232cc5534822c396a6ead82c3e3">Plus de détails...</a><br /></td></tr>
<tr class="separator:a680cb232cc5534822c396a6ead82c3e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3d9908001b7a7c04153dbed15fc132d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpopulation.html#ac3d9908001b7a7c04153dbed15fc132d">update_fitness</a> ()</td></tr>
<tr class="memdesc:ac3d9908001b7a7c04153dbed15fc132d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Méthode de mise à jour de la fitness pour toute une population.  <a href="#ac3d9908001b7a7c04153dbed15fc132d">Plus de détails...</a><br /></td></tr>
<tr class="separator:ac3d9908001b7a7c04153dbed15fc132d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3804614ba41583ae7cb5e2ba8cfca059"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpopulation.html#a3804614ba41583ae7cb5e2ba8cfca059">population_vierge</a> ()</td></tr>
<tr class="separator:a3804614ba41583ae7cb5e2ba8cfca059"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a382a8a2dc10109b96c9342bedfa5917f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpopulation.html#a382a8a2dc10109b96c9342bedfa5917f">add_genome</a> (<a class="el" href="classgenome.html">genome</a> gen)</td></tr>
<tr class="memdesc:a382a8a2dc10109b96c9342bedfa5917f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Méthode d'ajout d'un génome dans une population.  <a href="#a382a8a2dc10109b96c9342bedfa5917f">Plus de détails...</a><br /></td></tr>
<tr class="separator:a382a8a2dc10109b96c9342bedfa5917f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3d0b8c13b506e8013d2744646a06e52"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpopulation.html#af3d0b8c13b506e8013d2744646a06e52">del_genome</a> (int i)</td></tr>
<tr class="memdesc:af3d0b8c13b506e8013d2744646a06e52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Méthode de suppression d'un génome dans une population.  <a href="#af3d0b8c13b506e8013d2744646a06e52">Plus de détails...</a><br /></td></tr>
<tr class="separator:af3d0b8c13b506e8013d2744646a06e52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb5a4974137e4666fde116ccd569fd53"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpopulation.html#aeb5a4974137e4666fde116ccd569fd53">fitness_sort</a> (<a class="el" href="classgenome.html">genome</a> gen1, <a class="el" href="classgenome.html">genome</a> gen2)</td></tr>
<tr class="separator:aeb5a4974137e4666fde116ccd569fd53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4c405f80ea35197aabf966f6351b66d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpopulation.html#ab4c405f80ea35197aabf966f6351b66d">sort_by_fitness</a> ()</td></tr>
<tr class="memdesc:ab4c405f80ea35197aabf966f6351b66d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Méthode de tri d'une population.  <a href="#ab4c405f80ea35197aabf966f6351b66d">Plus de détails...</a><br /></td></tr>
<tr class="separator:ab4c405f80ea35197aabf966f6351b66d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fdddf622c27cab0a5f0e7c3e2eb11e5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpopulation.html#a4fdddf622c27cab0a5f0e7c3e2eb11e5">crossover</a> ()</td></tr>
<tr class="memdesc:a4fdddf622c27cab0a5f0e7c3e2eb11e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Méthode principale du crossover.  <a href="#a4fdddf622c27cab0a5f0e7c3e2eb11e5">Plus de détails...</a><br /></td></tr>
<tr class="separator:a4fdddf622c27cab0a5f0e7c3e2eb11e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab8d439ae720786ad752a9b686f9549c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpopulation.html#aab8d439ae720786ad752a9b686f9549c">selection</a> ()</td></tr>
<tr class="memdesc:aab8d439ae720786ad752a9b686f9549c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Méthode de la selection des génomes.  <a href="#aab8d439ae720786ad752a9b686f9549c">Plus de détails...</a><br /></td></tr>
<tr class="separator:aab8d439ae720786ad752a9b686f9549c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca293f7c655589c7cbde8fa4c027c2b4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpopulation.html#aca293f7c655589c7cbde8fa4c027c2b4">mutation</a> ()</td></tr>
<tr class="memdesc:aca293f7c655589c7cbde8fa4c027c2b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Méthode de mutation pour une population.  <a href="#aca293f7c655589c7cbde8fa4c027c2b4">Plus de détails...</a><br /></td></tr>
<tr class="separator:aca293f7c655589c7cbde8fa4c027c2b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a464021e55fa07b081d8cac1139453524"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpopulation.html#a464021e55fa07b081d8cac1139453524">toString</a> () const </td></tr>
<tr class="separator:a464021e55fa07b081d8cac1139453524"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Description détaillée</h2>
<div class="textblock"><p>Classe population. </p>
<p>Celle-ci est simplement composée d'un vector de génomes. Pour plus d'informations sur les génomes, merci de consulter la documentation relative aux génomes. </p>
</div><h2 class="groupheader">Documentation des constructeurs et destructeur</h2>
<a class="anchor" id="a9866a5e2211df558b8e63e30177a4ae1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">population::population </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a6ba6cfda62b8534be70ae3945a906d05"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">population::~population </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Documentation des fonctions membres</h2>
<a class="anchor" id="a382a8a2dc10109b96c9342bedfa5917f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void population::add_genome </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgenome.html">genome</a>&#160;</td>
          <td class="paramname"><em>gen</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Méthode d'ajout d'un génome dans une population. </p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">gen</td><td>genome le génome ajouté en fin de population </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Renvoie</dt><dd>void </dd></dl>

</div>
</div>
<a class="anchor" id="a4fdddf622c27cab0a5f0e7c3e2eb11e5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void population::crossover </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Méthode principale du crossover. </p>
<p>Cette méthode va parcourir la population et sélectionner 2 génomes dans l'ordre de la population. On génère un entier entre 0 et 1, si celui-ci est inférieur à CROSSOVERRATE, alors on fait un crossover sur ces 2 génomes. Cela consiste à prendre une portion (définie aléatoirement) de caractères dans le premier génome, et le reste dans le second. </p><dl class="section return"><dt>Renvoie</dt><dd>void </dd></dl>

</div>
</div>
<a class="anchor" id="af3d0b8c13b506e8013d2744646a06e52"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void population::del_genome </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Méthode de suppression d'un génome dans une population. </p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>int l'indice dans la population où le génome est supprimé </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Renvoie</dt><dd>void </dd></dl>

</div>
</div>
<a class="anchor" id="aeb5a4974137e4666fde116ccd569fd53"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool population::fitness_sort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgenome.html">genome</a>&#160;</td>
          <td class="paramname"><em>gen1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgenome.html">genome</a>&#160;</td>
          <td class="paramname"><em>gen2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a3dd43bd359b929c93819e57ba5d86c30"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgenome.html">genome</a> population::getbestgenome </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Méthode qui renvoie le génome avec la meilleure fitness. </p>
<dl class="section return"><dt>Renvoie</dt><dd>genome le génome avec la fitness la plus élevée dans la population </dd></dl>

</div>
</div>
<a class="anchor" id="ab1d61dd5910f85fd9d327de3910c33e0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="classgenome.html">genome</a> &gt; population::getpop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a680cb232cc5534822c396a6ead82c3e3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void population::initialiser_population </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Méthode de création d'une population vide. </p>
<p>On ajoute NBGENOME vides dans une population </p><dl class="section return"><dt>Renvoie</dt><dd>void </dd></dl>

</div>
</div>
<a class="anchor" id="aca293f7c655589c7cbde8fa4c027c2b4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void population::mutation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Méthode de mutation pour une population. </p>
<p>On applique la méthode mutation de la classe genome dans toute la population </p><dl class="section return"><dt>Renvoie</dt><dd>void </dd></dl>

</div>
</div>
<a class="anchor" id="a3804614ba41583ae7cb5e2ba8cfca059"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void population::population_vierge </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aab8d439ae720786ad752a9b686f9549c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void population::selection </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Méthode de la selection des génomes. </p>
<p>On met d'abord à jour la fitness de la population, pour la trier ensuite pour mettre les génomes avec la meilleure fitness au début et la pire au fond de la population On conserve alors un certain pourcentage (défini en paramètres par ELITRATE) de génomes intacts - principe d'élitisme. La méthode de selection qu'on utilise alors ensuite est celle de la roulette : on additionne les fitness de toute la population, ce qui va créer un intervalle [0;F] On va alors choisir un nombre aléatoire dans cet intervalle [0;F], et prendre le génome dont la fitness se situe à cet endroit dans l'intervalle. Ainsi, les génomes avec une grande fitness ont plus de chances d'être selectionnés, tout en gardant un processus de selection aléatoire. </p><dl class="section return"><dt>Renvoie</dt><dd>void </dd></dl>

</div>
</div>
<a class="anchor" id="a751d56be6b96d71f3d9457c137a10db1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void population::setpop </td>
          <td>(</td>
          <td class="paramtype">vector&lt; <a class="el" href="classgenome.html">genome</a> &gt;&#160;</td>
          <td class="paramname"><em>newpop</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab4c405f80ea35197aabf966f6351b66d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void population::sort_by_fitness </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Méthode de tri d'une population. </p>
<p>Le but de cette méthode est de trier les différents génome d'une population selon une certaine règle. La règle ici définie est de positionner les génomes avec la meilleure fitness au début de la population. </p><dl class="section return"><dt>Renvoie</dt><dd>void </dd></dl>

</div>
</div>
<a class="anchor" id="a464021e55fa07b081d8cac1139453524"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string population::toString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ac3d9908001b7a7c04153dbed15fc132d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void population::update_fitness </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Méthode de mise à jour de la fitness pour toute une population. </p>
<p>Cette méthode appelle la méthode updatefitness définie dans la classe genome à tous les génomes de la population </p><dl class="section return"><dt>Renvoie</dt><dd>void </dd></dl>

</div>
</div>
<a class="anchor" id="a8df089ad3944b829708ff65e14b913ba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void population::update_muterate </td>
          <td>(</td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>MUTERATE</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fonction de mise à jour du Muterate variable si l'algorithme vient à stagner. </p>
<p>Comment repérer que l'algorithme stagne ? On compare la fitness du premier génome de la population (qui au moment de l'execution du main est le meilleur) avec le génome médian. Si la différence de fitness est inférieure au DELTAFITNESS fixé en paramètre, cela signifie que l'algorithme stagne car au moins la moitié des génomes ont la même fitness que le meilleur génome de la population. Dans ce cas, on multiplie notre muterate actuel par un certain coefficient. Cela est particulièrement utile lorsqu'il ne manque qu'une ou 2 lettres pour atteindre la chaîne cible. On souahite alors un muterate elevé pour brasser le plus de solutions possibles, sans que celui-ci soit trop elevé pour éviter de brasser trop de solutions inutiles, d'où l'introduction d'un seuil MUTERATEMAX.</p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">MUTERATE</td><td>double&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Renvoie</dt><dd>void* </dd></dl>

</div>
</div>
<hr/>La documentation de cette classe a été générée à partir des fichiers suivants :<ul>
<li>include/<a class="el" href="population_8h_source.html">population.h</a></li>
<li>src/<a class="el" href="population_8cpp.html">population.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Généré le Vendredi 27 Mai 2016 12:46:56 pour Algorithme Genetique par &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
